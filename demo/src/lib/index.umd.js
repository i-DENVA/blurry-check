!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).BlurryCheck={})}(this,function(e){"use strict";const t={getFloat32Array:e=>Array.isArray(e)?e.slice(0):new Float32Array(e),createImageData(e,t){const n=(()=>{if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Canvas not available in this environment")})().getContext("2d");if(!n)throw new Error("Could not get 2D context");return n.createImageData(e,t)},luminance(e){const t=this.createImageData(e.width,e.height),n=t.data,a=e.data;for(let e=0;e<a.length;e+=4){const t=.2126*a[e]+.7152*a[e+1]+.0722*a[e+2];n[e]=n[e+1]=n[e+2]=t,n[e+3]=a[e+3]}return t},convolve(e,t,n){const a=Math.round(Math.sqrt(t.length)),i=Math.floor(a/2),o=e.data,s=e.width,r=e.height,l=s,d=r,c=this.createImageData(l,d),h=c.data,g=n?1:0;for(let e=0;e<d;e++)for(let n=0;n<l;n++){const d=4*(e*l+n);let c=0,u=0,f=0,m=0;for(let l=0;l<a;l++)for(let d=0;d<a;d++){const h=4*(Math.min(r-1,Math.max(0,e+l-i))*s+Math.min(s-1,Math.max(0,n+d-i))),g=t[l*a+d];c+=o[h]*g,u+=o[h+1]*g,f+=o[h+2]*g,m+=o[h+3]*g}h[d]=c,h[d+1]=u,h[d+2]=f,h[d+3]=m+g*(255-m)}return c},gaussianBlur(e,t){if((t=Math.abs(t))<=1)return e;const n=t/2,a=Math.ceil(t)+(1-Math.ceil(t)%2),i=this.getFloat32Array(a),o=(n+.5)/3,s=o*o,r=1/Math.sqrt(2*Math.PI*s),l=-1/(2*o*o),d=Math.floor(a/2);let c=0;for(let e=0;e<a;e++){const t=e-d,n=r*Math.exp(t*t*l);Float32Array,i[e]=n,c+=n}for(let e=0;e<i.length;e++)Float32Array,i[e]/=c;const h=this.convolve(e,i,!0);return this.convolve(h,i,!0)}};class n{constructor(e="https://docs.opencv.org/4.5.4/opencv.js"){this.loading=!1,this.loaded=!1,this.openCvUrl=e}static getInstance(e){return n.instance||(n.instance=new n(e)),n.instance}async loadOpenCV(){if("undefined"==typeof window)throw new Error("OpenCV.js can only be loaded in browser environments");if(this.loaded&&window.cv)return Promise.resolve();if(this.loading)return this.waitForLoad();this.loading=!0;try{const e=document.querySelector("#opencv-script");e&&document.body.removeChild(e);const t=document.createElement("script");t.src=this.openCvUrl,t.async=!0,t.id="opencv-script";const n=new Promise((e,n)=>{t.onload=()=>{const t=setInterval(()=>{window.cv&&(clearInterval(t),this.loaded=!0,this.loading=!1,e())},100);setTimeout(()=>{clearInterval(t),this.loading=!1,n(new Error("OpenCV loading timeout"))},1e4)},t.onerror=()=>{this.loading=!1,n(new Error("Failed to load OpenCV"))}});document.body.appendChild(t),await n}catch(e){throw this.loading=!1,e}}async waitForLoad(){return new Promise((e,t)=>{const n=setInterval(()=>{this.loading||(clearInterval(n),this.loaded&&window.cv?e():t(new Error("OpenCV failed to load")))},100);setTimeout(()=>{clearInterval(n),t(new Error("OpenCV loading timeout"))},15e3)})}isLoaded(){return this.loaded&&"undefined"!=typeof window&&!!window.cv}getCV(){if(!this.isLoaded())throw new Error("OpenCV is not loaded. Call loadOpenCV() first.");return window.cv}}class a{constructor(e={}){var t,a,i,o,s,r;this.config={edgeWidthThreshold:null!==(t=e.edgeWidthThreshold)&&void 0!==t?t:.5,laplacianThreshold:null!==(a=e.laplacianThreshold)&&void 0!==a?a:100,method:null!==(i=e.method)&&void 0!==i?i:"edge",openCvUrl:null!==(o=e.openCvUrl)&&void 0!==o?o:"https://docs.opencv.org/4.5.4/opencv.js",canvas:null!==(s=e.canvas)&&void 0!==s?s:this.createCanvas(),debug:null!==(r=e.debug)&&void 0!==r&&r},this.openCvLoader=n.getInstance(this.config.openCvUrl)}createCanvas(){if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Canvas not available in this environment")}log(e,...t){this.config.debug&&console.log(`[BlurDetector] ${e}`,...t)}detectEdges(e){const n=t.luminance(e),a=t.getFloat32Array([1,0,-1,2,0,-2,1,0,-1]);return t.convolve(n,a,!0)}reducedPixels(e){const{data:t,width:n}=e,a=4*n,i=[];for(let e=0;e<t.length;e+=a){const o=new Uint8ClampedArray(n);let s=0;for(let n=e;n<e+a;n+=4)o[s]=t[n],s+=1;i.push(o)}return i}detectBlur(e){const t=e[0].length,n=e.length;let a=0,i=0;for(let o=0;o<n;o++){let n=-1;for(let s=0;s<t;s++){const t=e[o][s];if(n>=0&&s>n){const r=e[o][s-1];if(t<r){if(r>=20){a++,i+=s-n-1}n=-1}}0===t&&(n=s)}}if(0===a)return{width:t,height:n,numEdges:0,avgEdgeWidth:0,avgEdgeWidthPerc:0};const o=i/a;return{width:t,height:n,numEdges:a,avgEdgeWidth:o,avgEdgeWidthPerc:o/t*100}}measureBlurByEdges(e){const t=this.detectEdges(e),n=this.reducedPixels(t);return this.detectBlur(n)}async detectBlurrinessWithOpenCV(e){this.openCvLoader.isLoaded()||await this.openCvLoader.loadOpenCV();const t=this.openCvLoader.getCV(),n=t.matFromImageData(e),a=new t.Mat;t.cvtColor(n,a,t.COLOR_RGBA2GRAY,0);const i=new t.Mat;t.Laplacian(a,i,t.CV_64F);const o=new t.Mat,s=new t.Mat;t.meanStdDev(i,o,s);const r=s.data64F[0]**2;return n.delete(),a.delete(),i.delete(),o.delete(),s.delete(),r}async getImageData(e){if(e instanceof ImageData)return e;const t=this.config.canvas,n=t.getContext("2d");if(!n)throw new Error("Could not get 2D context from canvas");if(e instanceof File)return new Promise((a,i)=>{const o=new FileReader;o.onload=e=>{var o;const s=new Image;s.onload=()=>{t.width=s.width,t.height=s.height,n.drawImage(s,0,0),a(n.getImageData(0,0,t.width,t.height))},s.onerror=i,s.src=null===(o=e.target)||void 0===o?void 0:o.result},o.onerror=i,o.readAsDataURL(e)});if(e instanceof HTMLImageElement)return t.width=e.width,t.height=e.height,n.drawImage(e,0,0),n.getImageData(0,0,t.width,t.height);if(e instanceof HTMLCanvasElement){const t=e.getContext("2d");if(!t)throw new Error("Could not get 2D context from source canvas");return t.getImageData(0,0,e.width,e.height)}throw new Error("Unsupported input type")}async analyzeImage(e){this.log("Starting blur analysis with method:",this.config.method);const t=await this.getImageData(e);this.log("Image data obtained:",t.width,"x",t.height);const n={isBlurry:!1,confidence:0,metrics:{},method:this.config.method};try{if("edge"===this.config.method||"both"===this.config.method){const e=this.measureBlurByEdges(t);n.metrics.edgeAnalysis=e;const a=e.avgEdgeWidthPerc>this.config.edgeWidthThreshold,i=e.numEdges<t.width*t.height/1e4,o=a||i;this.log("Edge analysis result:",e,"isBlurry:",a,"lowEdgeCount:",i,"combined:",o),"edge"===this.config.method&&(n.isBlurry=o,n.confidence=Math.min(e.avgEdgeWidthPerc/this.config.edgeWidthThreshold,1))}if("laplacian"===this.config.method||"both"===this.config.method)try{const e=await this.detectBlurrinessWithOpenCV(t);n.metrics.laplacianVariance=e;const a=e<this.config.laplacianThreshold;this.log("Laplacian analysis result:",e,"isBlurry:",a),"laplacian"===this.config.method&&(n.isBlurry=a,n.confidence=Math.min(this.config.laplacianThreshold/e,1))}catch(e){if(this.log("OpenCV analysis failed, falling back to edge detection:",e),"laplacian"===this.config.method){const e=this.measureBlurByEdges(t);n.metrics.edgeAnalysis=e,n.isBlurry=e.avgEdgeWidthPerc>this.config.edgeWidthThreshold,n.confidence=Math.min(e.avgEdgeWidthPerc/this.config.edgeWidthThreshold,1),n.method="edge (fallback)"}}if("both"===this.config.method){const e=!!n.metrics.edgeAnalysis&&n.metrics.edgeAnalysis.avgEdgeWidthPerc>this.config.edgeWidthThreshold,a=!!n.metrics.edgeAnalysis&&n.metrics.edgeAnalysis.numEdges<t.width*t.height/1e4,i=e||a,o=!!n.metrics.laplacianVariance&&n.metrics.laplacianVariance<this.config.laplacianThreshold;n.isBlurry=i||o;const s=n.metrics.edgeAnalysis?Math.min(n.metrics.edgeAnalysis.avgEdgeWidthPerc/this.config.edgeWidthThreshold,1):0,r=n.metrics.laplacianVariance?Math.min(this.config.laplacianThreshold/n.metrics.laplacianVariance,1):0;n.confidence=Math.max(s,r)}return this.log("Final analysis result:",n),n}catch(e){throw this.log("Analysis failed:",e),new Error(`Blur analysis failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async isBlurry(e){return(await this.analyzeImage(e)).isBlurry}}var i=Object.freeze({__proto__:null,BlurDetector:a});class o{constructor(e={}){this.pdfLib=null,this.loading=!1,this.config=e,this.blurDetector=new a(e)}log(e,...t){this.config.debug&&console.log(`[PDFAnalyzer] ${e}`,...t)}async loadPdfJS(){if("undefined"==typeof window)throw new Error("PDF.js can only be loaded in browser environments");if(this.pdfLib)return Promise.resolve();if(this.loading)return this.waitForLoad();this.loading=!0;try{const e=document.querySelector("#pdfjs-script");e&&document.body.removeChild(e);const t=document.createElement("script");t.src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js",t.async=!0,t.id="pdfjs-script";const n=new Promise((e,n)=>{t.onload=()=>{window.pdfjsLib?(window.pdfjsLib.GlobalWorkerOptions.workerSrc="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js",this.pdfLib=window.pdfjsLib,this.loading=!1,e()):(this.loading=!1,n(new Error("PDF.js not available after loading")))},t.onerror=()=>{this.loading=!1,n(new Error("Failed to load PDF.js"))}});document.body.appendChild(t),await n}catch(e){throw this.loading=!1,e}}async waitForLoad(){return new Promise((e,t)=>{const n=setInterval(()=>{this.loading||(clearInterval(n),this.pdfLib?e():t(new Error("PDF.js failed to load")))},100);setTimeout(()=>{clearInterval(n),t(new Error("PDF.js loading timeout"))},15e3)})}async checkPdfPageQuality(e,t){const n=await e.getPage(t),a=[1,1.5,2],o=[];for(const e of a){const a=n.getViewport({scale:e}),s=this.config.canvas||document.createElement("canvas"),r=s.getContext("2d");if(!r)throw new Error("Could not get 2D context from canvas");s.width=a.width,s.height=a.height;const l={canvasContext:r,viewport:a};await n.render(l).promise;const d=r.getImageData(0,0,s.width,s.height),c=new((await Promise.resolve().then(function(){return i})).BlurDetector)({...this.config,edgeWidthThreshold:Math.min(this.config.edgeWidthThreshold||.5,.25),method:"edge",debug:this.config.debug}),h=await c.analyzeImage(d);h.method=`${h.method} (scale ${e}x)`,o.push(h),this.log(`Page ${t} at ${e}x scale:`,h)}const s=o.filter(e=>e.isBlurry).length,r=o.reduce((e,t)=>e+t.confidence,0)/o.length,l=o[o.length-1];return{...l,isBlurry:s>0,confidence:Math.max(r,s/o.length),method:`Multi-scale analysis (${s}/${o.length} scales detected blur)`,metrics:{...l.metrics,scaleResults:o.map(e=>{var t;return{scale:parseFloat((null===(t=e.method.match(/scale ([\d.]+)x/))||void 0===t?void 0:t[1])||"1"),isBlurry:e.isBlurry,confidence:e.confidence,edgeAnalysis:e.metrics.edgeAnalysis}})}}}analyzePageContent(e,t){const n=e.items||[],a=n.map(e=>e.str).join(" ").trim(),i=a.length,o=1===t,s=i<200,r=i/Math.max(n.length,1),l=/bill|statement|invoice|report|summary|account|period/i.test(a),d=/\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4}|\w+ \d{1,2}, \d{4}/i.test(a),c=/\$[\d,]+\.?\d*|USD|EUR|GBP/i.test(a),h=o&&(s||l&&d&&c&&i<500);return this.log(`Page ${t} content analysis: textLength=${i}, textDensity=${r.toFixed(1)}, isLikelyHeader=${h}`),{isLikelyHeaderPage:h,textDensity:r,hasLowTextContent:s}}async analyzeTextSharpness(e,t){const n=await e.getPage(t),a=await n.getTextContent();if(0===a.items.length)return{textSharpnessScore:0,isTextBlurry:!0,textMetrics:{reason:"No text found"}};const i=n.getViewport({scale:3}),o=document.createElement("canvas"),s=o.getContext("2d");if(!s)throw new Error("Could not get 2D context for text analysis");o.width=i.width,o.height=i.height;const r={canvasContext:s,viewport:i,intent:"print"};await n.render(r).promise;const l=s.getImageData(0,0,o.width,o.height),d=this.calculateTextSharpness(l,a.items);return this.log(`Page ${t} text sharpness analysis:`,d),d}calculateTextSharpness(e,t){const{data:n,width:a,height:i}=e;let o=0,s=0,r=0;const l=Math.max(1,Math.floor(Math.min(a,i)/100));for(let e=0;e<i-5;e+=l)for(let t=0;t<a-5;t+=l){let i=0,l=0,d=0,c=0;for(let o=0;o<5;o++)for(let s=0;s<5;s++){const r=4*((e+o)*a+(t+s)),h=.299*n[r]+.587*n[r+1]+.114*n[r+2];if(i+=h,l+=h*h,d++,s<4&&o<4){const i=4*((e+o)*a+(t+s+1)),r=4*((e+o+1)*a+(t+s)),l=.299*n[i]+.587*n[i+1]+.114*n[i+2]-h,d=.299*n[r]+.587*n[r+1]+.114*n[r+2]-h,g=Math.sqrt(l*l+d*d);c=Math.max(c,g)}}if(d>0){const e=i/d,t=l/d-e*e;t>100&&(o+=t,r+=c,s++)}}const d=s>0?o/s:0,c=s>0?r/s:0,h=d/1e3+c/50;return{textSharpnessScore:h,isTextBlurry:h<.8,textMetrics:{avgVariance:d,avgEdgeIntensity:c,sampleCount:s,threshold:.8}}}async analyzePDF(e){this.log("Starting PDF analysis for file:",e.name),this.pdfLib||await this.loadPdfJS();try{const t=await e.arrayBuffer(),n=await this.pdfLib.getDocument({data:new Uint8Array(t)}).promise;let a="",i=!1;const o=[];this.log(`PDF has ${n.numPages} pages`);for(let e=1;e<=n.numPages;e++){this.log(`Analyzing page ${e}/${n.numPages}`);const t=await n.getPage(e),s=await t.getTextContent();0===s.items.length&&(i=!0),a+=s.items.map(e=>e.str).join(" ");try{const t=this.analyzePageContent(s,e),a=await this.checkPdfPageQuality(n,e);if(s.items.length>0)try{const i=await this.analyzeTextSharpness(n,e);let s=a.isBlurry||i.isTextBlurry;t.isLikelyHeaderPage&&(s=i.textSharpnessScore<.5,this.log(`Page ${e} identified as likely header/logo page - using lenient blur criteria`));const r={...a,isBlurry:s,confidence:Math.max(a.confidence,i.textSharpnessScore),method:`${a.method} + Text Analysis${t.isLikelyHeaderPage?" (Header-adjusted)":""}`,metrics:{...a.metrics,textSharpness:i,contentAnalysis:t}};o.push(r),this.log(`Page ${e} combined analysis:`,r)}catch(t){this.log(`Text analysis failed for page ${e}:`,t),o.push(a)}else o.push(a)}catch(t){this.log(`Failed to analyze page ${e}:`,t)}}const s=a.length>=10,r=i||!s;this.log(`PDF analysis complete. Scanned: ${r}, Text length: ${a.length}`);let l=!0;if(o.length>0){const e=o.filter(e=>e.isBlurry);if(o.length>1){const e=o.slice(1),t=e.filter(e=>e.isBlurry),n=o[0].isBlurry,a=t.length>0;n&&!a?(this.log("First page marked as blurry but rest are clear - likely false positive due to graphics/logos"),l=!0):l=!(t.length>=Math.ceil(e.length/2)),this.log(`Smart quality check: First page blurry: ${n}, Rest pages blurry: ${t.length}/${e.length}, Final decision: ${l?"Good":"Poor"}`)}else l=0===e.length,this.log(`Single page quality check: ${e.length}/${o.length} pages are blurry`);this.log("PDF type: "+(r?"Scanned":"Text-based"))}const d={isQualityGood:l,isScanned:r,pagesAnalyzed:n.numPages,textLength:a.length,pageResults:o.length>0?o:void 0};return this.log("Final PDF analysis result:",d),d}catch(e){throw this.log("PDF analysis failed:",e),new Error(`PDF analysis failed: ${e instanceof Error?e.message:"Unknown error"}`)}}async isGoodQuality(e){return(await this.analyzePDF(e)).isQualityGood}}class s{constructor(e={}){this.config={edgeWidthThreshold:.5,laplacianThreshold:100,method:"edge",debug:!1,...e},this.blurDetector=new a(this.config),this.pdfAnalyzer=new o(this.config)}async isImageBlurry(e){return this.blurDetector.isBlurry(e)}async analyzeImage(e){return this.blurDetector.analyzeImage(e)}async isPDFGoodQuality(e){return this.pdfAnalyzer.isGoodQuality(e)}async analyzePDF(e){return this.pdfAnalyzer.analyzePDF(e)}async analyzeFile(e,t={}){var n;const i=null===(n=e.name.split(".").pop())||void 0===n?void 0:n.toLowerCase(),s={...this.config,...t};if("pdf"===i){return new o(s).analyzePDF(e)}if(["png","jpg","jpeg","gif","bmp","webp"].includes(i||"")){return new a(s).analyzeImage(e)}throw new Error(`Unsupported file type: ${i}`)}async isFileGoodQuality(e,t={}){const n=await this.analyzeFile(e,t);return"isQualityGood"in n?n.isQualityGood:!n.isBlurry}updateConfig(e){this.config={...this.config,...e},this.blurDetector=new a(this.config),this.pdfAnalyzer=new o(this.config)}getConfig(){return{...this.config}}}e.BlurDetector=a,e.BlurryCheck=s,e.Filters=t,e.OpenCVLoader=n,e.PDFAnalyzer=o,e.analyzeFile=async function(e,t){return new s(t).analyzeFile(e,t)},e.default=s,e.isImageBlurry=async function(e,t){return new s(t).isImageBlurry(e)},e.isPDFGoodQuality=async function(e,t){return new s(t).isPDFGoodQuality(e)},Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=index.umd.js.map
