{"version":3,"file":"index.js","sources":["../src/filters.ts","../src/opencv-loader.ts","../src/blur-detector.ts","../src/pdf-analyzer.ts","../src/index.ts"],"sourcesContent":["/**\n * Canvas filter utilities for image processing\n */\n\nexport interface ImageFilters {\n  getFloat32Array(len: number | number[]): Float32Array | number[];\n  createImageData(w: number, h: number): ImageData;\n  luminance(pixels: ImageData): ImageData;\n  convolve(pixels: ImageData, weights: Float32Array | number[], opaque: boolean): ImageData;\n  gaussianBlur(pixels: ImageData, diameter: number): ImageData;\n}\n\nconst createCanvas = (): HTMLCanvasElement => {\n  if (typeof document !== 'undefined') {\n    return document.createElement('canvas');\n  }\n  // For Node.js environments, you would need canvas polyfill\n  throw new Error('Canvas not available in this environment');\n};\n\nexport const Filters: ImageFilters = {\n  getFloat32Array(len: number | number[]): Float32Array | number[] {\n    if (Array.isArray(len)) return len.slice(0);\n    return new Float32Array(len);\n  },\n\n  createImageData(w: number, h: number): ImageData {\n    const context = createCanvas().getContext('2d');\n    if (!context) {\n      throw new Error('Could not get 2D context');\n    }\n    return context.createImageData(w, h);\n  },\n\n  luminance(pixels: ImageData): ImageData {\n    const output = this.createImageData(pixels.width, pixels.height);\n    const dst = output.data;\n    const d = pixels.data;\n    for (let i = 0; i < d.length; i += 4) {\n      const r = d[i];\n      const g = d[i + 1];\n      const b = d[i + 2];\n      // CIE luminance for RGB\n      const v = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n      dst[i] = dst[i + 1] = dst[i + 2] = v;\n      dst[i + 3] = d[i + 3];\n    }\n    return output;\n  },\n\n  convolve(pixels: ImageData, weights: Float32Array | number[], opaque: boolean): ImageData {\n    const side = Math.round(Math.sqrt(weights.length));\n    const halfSide = Math.floor(side / 2);\n    const src = pixels.data;\n    const sw = pixels.width;\n    const sh = pixels.height;\n    const w = sw;\n    const h = sh;\n    const output = this.createImageData(w, h);\n    const dst = output.data;\n    const alphaFac = opaque ? 1 : 0;\n\n    for (let y = 0; y < h; y++) {\n      for (let x = 0; x < w; x++) {\n        const dstOff = (y * w + x) * 4;\n        let r = 0,\n          g = 0,\n          b = 0,\n          a = 0;\n\n        for (let cy = 0; cy < side; cy++) {\n          for (let cx = 0; cx < side; cx++) {\n            const scy = Math.min(sh - 1, Math.max(0, y + cy - halfSide));\n            const scx = Math.min(sw - 1, Math.max(0, x + cx - halfSide));\n            const srcOff = (scy * sw + scx) * 4;\n            const wt = weights[cy * side + cx];\n            r += src[srcOff] * wt;\n            g += src[srcOff + 1] * wt;\n            b += src[srcOff + 2] * wt;\n            a += src[srcOff + 3] * wt;\n          }\n        }\n\n        dst[dstOff] = r;\n        dst[dstOff + 1] = g;\n        dst[dstOff + 2] = b;\n        dst[dstOff + 3] = a + alphaFac * (255 - a);\n      }\n    }\n    return output;\n  },\n\n  gaussianBlur(pixels: ImageData, diameter: number): ImageData {\n    diameter = Math.abs(diameter);\n    if (diameter <= 1) return pixels;\n\n    const radius = diameter / 2;\n    const len = Math.ceil(diameter) + (1 - (Math.ceil(diameter) % 2));\n    const weights = this.getFloat32Array(len);\n\n    // Calculate Gaussian weights\n    const rho = (radius + 0.5) / 3;\n    const rhoSq = rho * rho;\n    const gaussianFactor = 1 / Math.sqrt(2 * Math.PI * rhoSq);\n    const rhoFactor = -1 / (2 * rho * rho);\n    const middle = Math.floor(len / 2);\n\n    let wsum = 0;\n    for (let i = 0; i < len; i++) {\n      const x = i - middle;\n      const gx = gaussianFactor * Math.exp(x * x * rhoFactor);\n      if (weights instanceof Float32Array) {\n        weights[i] = gx;\n      } else {\n        weights[i] = gx;\n      }\n      wsum += gx;\n    }\n\n    // Normalize weights\n    for (let i = 0; i < weights.length; i++) {\n      if (weights instanceof Float32Array) {\n        weights[i] /= wsum;\n      } else {\n        weights[i] /= wsum;\n      }\n    }\n\n    // Apply horizontal and vertical blur\n    const firstPass = this.convolve(pixels, weights, true);\n    return this.convolve(firstPass, weights, true);\n  }\n};","/**\n * OpenCV loader utility for dynamic loading of OpenCV.js\n */\n\ndeclare global {\n  interface Window {\n    cv?: any;\n  }\n}\n\nexport class OpenCVLoader {\n  private static instance: OpenCVLoader;\n  private loading: boolean = false;\n  private loaded: boolean = false;\n  private openCvUrl: string;\n\n  constructor(openCvUrl: string = 'https://docs.opencv.org/4.5.4/opencv.js') {\n    this.openCvUrl = openCvUrl;\n  }\n\n  static getInstance(openCvUrl?: string): OpenCVLoader {\n    if (!OpenCVLoader.instance) {\n      OpenCVLoader.instance = new OpenCVLoader(openCvUrl);\n    }\n    return OpenCVLoader.instance;\n  }\n\n  async loadOpenCV(): Promise<void> {\n    if (typeof window === 'undefined') {\n      throw new Error('OpenCV.js can only be loaded in browser environments');\n    }\n\n    // If OpenCV is already loaded\n    if (this.loaded && window.cv) {\n      return Promise.resolve();\n    }\n\n    // If currently loading, wait for it\n    if (this.loading) {\n      return this.waitForLoad();\n    }\n\n    this.loading = true;\n\n    try {\n      // Remove existing script if any\n      const existingScript = document.querySelector('#opencv-script');\n      if (existingScript) {\n        document.body.removeChild(existingScript);\n      }\n\n      const script = document.createElement('script');\n      script.src = this.openCvUrl;\n      script.async = true;\n      script.id = 'opencv-script';\n\n      const loadPromise = new Promise<void>((resolve, reject) => {\n        script.onload = () => {\n          // Check for OpenCV initialization\n          const checkInterval = setInterval(() => {\n            if (window.cv) {\n              clearInterval(checkInterval);\n              this.loaded = true;\n              this.loading = false;\n              resolve();\n            }\n          }, 100);\n\n          // Timeout after 10 seconds\n          setTimeout(() => {\n            clearInterval(checkInterval);\n            this.loading = false;\n            reject(new Error('OpenCV loading timeout'));\n          }, 10000);\n        };\n        \n        script.onerror = () => {\n          this.loading = false;\n          reject(new Error('Failed to load OpenCV'));\n        };\n      });\n\n      document.body.appendChild(script);\n      await loadPromise;\n    } catch (error) {\n      this.loading = false;\n      throw error;\n    }\n  }\n\n  private async waitForLoad(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const checkInterval = setInterval(() => {\n        if (!this.loading) {\n          clearInterval(checkInterval);\n          if (this.loaded && window.cv) {\n            resolve();\n          } else {\n            reject(new Error('OpenCV failed to load'));\n          }\n        }\n      }, 100);\n\n      // Timeout after 15 seconds\n      setTimeout(() => {\n        clearInterval(checkInterval);\n        reject(new Error('OpenCV loading timeout'));\n      }, 15000);\n    });\n  }\n\n  isLoaded(): boolean {\n    return this.loaded && typeof window !== 'undefined' && !!window.cv;\n  }\n\n  getCV(): any {\n    if (!this.isLoaded()) {\n      throw new Error('OpenCV is not loaded. Call loadOpenCV() first.');\n    }\n    return window.cv;\n  }\n}","/**\n * Core blur detection functionality\n */\n\nimport { Filters } from './filters';\nimport { OpenCVLoader } from './opencv-loader';\nimport { BlurDetectionConfig, BlurAnalysisResult } from './types';\n\nexport class BlurDetector {\n  private config: Required<BlurDetectionConfig>;\n  private openCvLoader: OpenCVLoader;\n\n  constructor(config: BlurDetectionConfig = {}) {\n    this.config = {\n      edgeWidthThreshold: config.edgeWidthThreshold ?? 0.5,\n      laplacianThreshold: config.laplacianThreshold ?? 100,\n      method: config.method ?? 'edge',\n      openCvUrl: config.openCvUrl ?? 'https://docs.opencv.org/4.5.4/opencv.js',\n      canvas: config.canvas ?? this.createCanvas(),\n      debug: config.debug ?? false\n    };\n\n    this.openCvLoader = OpenCVLoader.getInstance(this.config.openCvUrl);\n  }\n\n  private createCanvas(): HTMLCanvasElement {\n    if (typeof document !== 'undefined') {\n      return document.createElement('canvas');\n    }\n    throw new Error('Canvas not available in this environment');\n  }\n\n  private log(message: string, ...args: any[]): void {\n    if (this.config.debug) {\n      console.log(`[BlurDetector] ${message}`, ...args);\n    }\n  }\n\n  /**\n   * Analyze image for blur using edge detection method\n   */\n  private detectEdges(imageData: ImageData): ImageData {\n    const greyscaled = Filters.luminance(imageData);\n    const sobelKernel = Filters.getFloat32Array([1, 0, -1, 2, 0, -2, 1, 0, -1]);\n    return Filters.convolve(greyscaled, sobelKernel, true);\n  }\n\n  private reducedPixels(imageData: ImageData): Uint8ClampedArray[] {\n    const { data: pixels, width } = imageData;\n    const rowLen = width * 4;\n    const rows: Uint8ClampedArray[] = [];\n\n    for (let y = 0; y < pixels.length; y += rowLen) {\n      const row = new Uint8ClampedArray(width);\n      let x = 0;\n      for (let i = y; i < y + rowLen; i += 4) {\n        row[x] = pixels[i];\n        x += 1;\n      }\n      rows.push(row);\n    }\n    return rows;\n  }\n\n  private detectBlur(pixels: Uint8ClampedArray[]): {\n    width: number;\n    height: number;\n    numEdges: number;\n    avgEdgeWidth: number;\n    avgEdgeWidthPerc: number;\n  } {\n    const width = pixels[0].length;\n    const height = pixels.length;\n    let numEdges = 0;\n    let sumEdgeWidths = 0;\n\n    for (let y = 0; y < height; y++) {\n      let edgeStart = -1;\n\n      for (let x = 0; x < width; x++) {\n        const value = pixels[y][x];\n\n        if (edgeStart >= 0 && x > edgeStart) {\n          const oldValue = pixels[y][x - 1];\n          if (value < oldValue) {\n            if (oldValue >= 20) {\n              const edgeWidth = x - edgeStart - 1;\n              numEdges++;\n              sumEdgeWidths += edgeWidth;\n            }\n            edgeStart = -1;\n          }\n        }\n\n        if (value === 0) {\n          edgeStart = x;\n        }\n      }\n    }\n\n    if (numEdges === 0) {\n      return {\n        width,\n        height,\n        numEdges: 0,\n        avgEdgeWidth: 0,\n        avgEdgeWidthPerc: 0,\n      };\n    }\n\n    const avgEdgeWidth = sumEdgeWidths / numEdges;\n    const avgEdgeWidthPerc = (avgEdgeWidth / width) * 100;\n\n    return {\n      width,\n      height,\n      numEdges,\n      avgEdgeWidth,\n      avgEdgeWidthPerc,\n    };\n  }\n\n  /**\n   * Measure blur using edge width analysis\n   */\n  private measureBlurByEdges(imageData: ImageData) {\n    const edges = this.detectEdges(imageData);\n    const reducedPixelData = this.reducedPixels(edges);\n    return this.detectBlur(reducedPixelData);\n  }\n\n  /**\n   * Detect blur using OpenCV Laplacian variance method\n   */\n  private async detectBlurrinessWithOpenCV(imageData: ImageData): Promise<number> {\n    if (!this.openCvLoader.isLoaded()) {\n      await this.openCvLoader.loadOpenCV();\n    }\n\n    const cv = this.openCvLoader.getCV();\n    \n    const mat = cv.matFromImageData(imageData);\n    const gray = new cv.Mat();\n    cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY, 0);\n\n    const laplacian = new cv.Mat();\n    cv.Laplacian(gray, laplacian, cv.CV_64F);\n\n    const meanStdDev = new cv.Mat();\n    const stddev = new cv.Mat();\n    cv.meanStdDev(laplacian, meanStdDev, stddev);\n\n    const variance = stddev.data64F[0] ** 2;\n\n    // Cleanup OpenCV matrices\n    mat.delete();\n    gray.delete();\n    laplacian.delete();\n    meanStdDev.delete();\n    stddev.delete();\n\n    return variance;\n  }\n\n  /**\n   * Convert various input types to ImageData\n   */\n  private async getImageData(input: HTMLImageElement | HTMLCanvasElement | File | ImageData): Promise<ImageData> {\n    if (input instanceof ImageData) {\n      return input;\n    }\n\n    const canvas = this.config.canvas;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Could not get 2D context from canvas');\n    }\n\n    if (input instanceof File) {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = (e) => {\n          const img = new Image();\n          img.onload = () => {\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0);\n            resolve(ctx.getImageData(0, 0, canvas.width, canvas.height));\n          };\n          img.onerror = reject;\n          img.src = e.target?.result as string;\n        };\n        reader.onerror = reject;\n        reader.readAsDataURL(input);\n      });\n    }\n\n    if (input instanceof HTMLImageElement) {\n      canvas.width = input.width;\n      canvas.height = input.height;\n      ctx.drawImage(input, 0, 0);\n      return ctx.getImageData(0, 0, canvas.width, canvas.height);\n    }\n\n    if (input instanceof HTMLCanvasElement) {\n      const srcCtx = input.getContext('2d');\n      if (!srcCtx) {\n        throw new Error('Could not get 2D context from source canvas');\n      }\n      return srcCtx.getImageData(0, 0, input.width, input.height);\n    }\n\n    throw new Error('Unsupported input type');\n  }\n\n  /**\n   * Analyze an image for blur\n   */\n  async analyzeImage(\n    input: HTMLImageElement | HTMLCanvasElement | File | ImageData\n  ): Promise<BlurAnalysisResult> {\n    this.log('Starting blur analysis with method:', this.config.method);\n\n    const imageData = await this.getImageData(input);\n    this.log('Image data obtained:', imageData.width, 'x', imageData.height);\n\n    const result: BlurAnalysisResult = {\n      isBlurry: false,\n      confidence: 0,\n      metrics: {},\n      method: this.config.method\n    };\n\n    try {\n      if (this.config.method === 'edge' || this.config.method === 'both') {\n        const edgeAnalysis = this.measureBlurByEdges(imageData);\n        result.metrics.edgeAnalysis = edgeAnalysis;\n        \n        const isBlurryByEdge = edgeAnalysis.avgEdgeWidthPerc > this.config.edgeWidthThreshold;\n        \n        // Additional check for low edge count (often indicates blur in documents/PDFs)\n        const hasLowEdgeCount = edgeAnalysis.numEdges < (imageData.width * imageData.height) / 10000;\n        const combinedBlurCheck = isBlurryByEdge || hasLowEdgeCount;\n        \n        this.log('Edge analysis result:', edgeAnalysis, 'isBlurry:', isBlurryByEdge, 'lowEdgeCount:', hasLowEdgeCount, 'combined:', combinedBlurCheck);\n        \n        if (this.config.method === 'edge') {\n          result.isBlurry = combinedBlurCheck;\n          result.confidence = Math.min(edgeAnalysis.avgEdgeWidthPerc / this.config.edgeWidthThreshold, 1);\n        }\n      }\n\n      if (this.config.method === 'laplacian' || this.config.method === 'both') {\n        try {\n          const laplacianVariance = await this.detectBlurrinessWithOpenCV(imageData);\n          result.metrics.laplacianVariance = laplacianVariance;\n          \n          const isBlurryByLaplacian = laplacianVariance < this.config.laplacianThreshold;\n          this.log('Laplacian analysis result:', laplacianVariance, 'isBlurry:', isBlurryByLaplacian);\n          \n          if (this.config.method === 'laplacian') {\n            result.isBlurry = isBlurryByLaplacian;\n            result.confidence = Math.min(this.config.laplacianThreshold / laplacianVariance, 1);\n          }\n        } catch (error) {\n          this.log('OpenCV analysis failed, falling back to edge detection:', error);\n          if (this.config.method === 'laplacian') {\n            // Fallback to edge detection\n            const edgeAnalysis = this.measureBlurByEdges(imageData);\n            result.metrics.edgeAnalysis = edgeAnalysis;\n            result.isBlurry = edgeAnalysis.avgEdgeWidthPerc > this.config.edgeWidthThreshold;\n            result.confidence = Math.min(edgeAnalysis.avgEdgeWidthPerc / this.config.edgeWidthThreshold, 1);\n            result.method = 'edge (fallback)';\n          }\n        }\n      }\n\n      if (this.config.method === 'both') {\n        const edgeBlurry = result.metrics.edgeAnalysis ? \n          result.metrics.edgeAnalysis.avgEdgeWidthPerc > this.config.edgeWidthThreshold : false;\n        const hasLowEdgeCount = result.metrics.edgeAnalysis ? \n          result.metrics.edgeAnalysis.numEdges < (imageData.width * imageData.height) / 10000 : false;\n        const combinedEdgeBlurry = edgeBlurry || hasLowEdgeCount;\n        \n        const laplacianBlurry = result.metrics.laplacianVariance ? \n          result.metrics.laplacianVariance < this.config.laplacianThreshold : false;\n        \n        // Consider blurry if either method detects blur\n        result.isBlurry = combinedEdgeBlurry || laplacianBlurry;\n        \n        // Calculate combined confidence\n        const edgeConfidence = result.metrics.edgeAnalysis ? \n          Math.min(result.metrics.edgeAnalysis.avgEdgeWidthPerc / this.config.edgeWidthThreshold, 1) : 0;\n        const laplacianConfidence = result.metrics.laplacianVariance ? \n          Math.min(this.config.laplacianThreshold / result.metrics.laplacianVariance, 1) : 0;\n        \n        result.confidence = Math.max(edgeConfidence, laplacianConfidence);\n      }\n\n      this.log('Final analysis result:', result);\n      return result;\n\n    } catch (error) {\n      this.log('Analysis failed:', error);\n      throw new Error(`Blur analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Quick check if an image is blurry (returns boolean only)\n   */\n  async isBlurry(input: HTMLImageElement | HTMLCanvasElement | File | ImageData): Promise<boolean> {\n    const result = await this.analyzeImage(input);\n    return result.isBlurry;\n  }\n}","/**\n * PDF analysis functionality for blur detection\n */\n\nimport { BlurDetector } from './blur-detector';\nimport { BlurDetectionConfig, PDFAnalysisResult, BlurAnalysisResult } from './types';\n\ndeclare global {\n  interface Window {\n    pdfjsLib?: {\n      getDocument: (data: { data: Uint8Array }) => { promise: Promise<any> };\n      GlobalWorkerOptions: {\n        workerSrc: string;\n      };\n    };\n  }\n}\n\nexport class PDFAnalyzer {\n  private blurDetector: BlurDetector;\n  private config: BlurDetectionConfig;\n  private pdfLib: any = null;\n  private loading: boolean = false;\n\n  constructor(config: BlurDetectionConfig = {}) {\n    this.config = config;\n    this.blurDetector = new BlurDetector(config);\n  }\n\n  private log(message: string, ...args: any[]): void {\n    if (this.config.debug) {\n      console.log(`[PDFAnalyzer] ${message}`, ...args);\n    }\n  }\n\n  /**\n   * Load PDF.js library dynamically\n   */\n  private async loadPdfJS(): Promise<void> {\n    if (typeof window === 'undefined') {\n      throw new Error('PDF.js can only be loaded in browser environments');\n    }\n\n    if (this.pdfLib) {\n      return Promise.resolve();\n    }\n\n    if (this.loading) {\n      return this.waitForLoad();\n    }\n\n    this.loading = true;\n\n    try {\n      // Remove existing script if any\n      const existingScript = document.querySelector('#pdfjs-script');\n      if (existingScript) {\n        document.body.removeChild(existingScript);\n      }\n\n      const script = document.createElement('script');\n      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';\n      script.async = true;\n      script.id = 'pdfjs-script';\n\n      const loadPromise = new Promise<void>((resolve, reject) => {\n        script.onload = () => {\n          if (window.pdfjsLib) {\n            window.pdfjsLib.GlobalWorkerOptions.workerSrc =\n              'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';\n            this.pdfLib = window.pdfjsLib;\n            this.loading = false;\n            resolve();\n          } else {\n            this.loading = false;\n            reject(new Error('PDF.js not available after loading'));\n          }\n        };\n        script.onerror = () => {\n          this.loading = false;\n          reject(new Error('Failed to load PDF.js'));\n        };\n      });\n\n      document.body.appendChild(script);\n      await loadPromise;\n    } catch (error) {\n      this.loading = false;\n      throw error;\n    }\n  }\n\n  private async waitForLoad(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const checkInterval = setInterval(() => {\n        if (!this.loading) {\n          clearInterval(checkInterval);\n          if (this.pdfLib) {\n            resolve();\n          } else {\n            reject(new Error('PDF.js failed to load'));\n          }\n        }\n      }, 100);\n\n      // Timeout after 15 seconds\n      setTimeout(() => {\n        clearInterval(checkInterval);\n        reject(new Error('PDF.js loading timeout'));\n      }, 15000);\n    });\n  }\n\n  /**\n   * Check if a PDF page is blurry by rendering it at multiple scales and analyzing quality\n   */\n  private async checkPdfPageQuality(pdf: any, pageNumber: number): Promise<BlurAnalysisResult> {\n    const page = await pdf.getPage(pageNumber);\n    \n    // Test at multiple scales to get more accurate results\n    const scales = [1.0, 1.5, 2.0];\n    const results: BlurAnalysisResult[] = [];\n    \n    for (const scale of scales) {\n      const viewport = page.getViewport({ scale });\n      \n      const canvas = this.config.canvas || document.createElement('canvas');\n      const context = canvas.getContext('2d');\n      if (!context) {\n        throw new Error('Could not get 2D context from canvas');\n      }\n\n      canvas.width = viewport.width;\n      canvas.height = viewport.height;\n\n      const renderContext = { canvasContext: context, viewport };\n      await page.render(renderContext).promise;\n\n      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n      \n      // Use more sensitive settings for PDFs\n      const pdfBlurDetector = new (await import('./blur-detector')).BlurDetector({\n        ...this.config,\n        edgeWidthThreshold: Math.min(this.config.edgeWidthThreshold || 0.5, 0.25), // More sensitive\n        method: 'edge', // Consistent method\n        debug: this.config.debug\n      });\n      \n      const result = await pdfBlurDetector.analyzeImage(imageData);\n      result.method = `${result.method} (scale ${scale}x)`;\n      results.push(result);\n      \n      this.log(`Page ${pageNumber} at ${scale}x scale:`, result);\n    }\n    \n    // Combine results - if ANY scale shows blur, consider it blurry\n    const blurryCount = results.filter(r => r.isBlurry).length;\n    const avgConfidence = results.reduce((sum, r) => sum + r.confidence, 0) / results.length;\n    \n    // Use the most detailed result (highest scale) as base\n    const bestResult = results[results.length - 1];\n    \n    return {\n      ...bestResult,\n      isBlurry: blurryCount > 0, // Any scale showing blur = blurry\n      confidence: Math.max(avgConfidence, blurryCount / results.length),\n      method: `Multi-scale analysis (${blurryCount}/${results.length} scales detected blur)`,\n      metrics: {\n        ...bestResult.metrics,\n        // Add multi-scale information\n        scaleResults: results.map(r => ({\n          scale: parseFloat(r.method.match(/scale ([\\d.]+)x/)?.[1] || '1'),\n          isBlurry: r.isBlurry,\n          confidence: r.confidence,\n          edgeAnalysis: r.metrics.edgeAnalysis\n        }))\n      }\n    };\n  }\n\n  /**\n   * Analyze page content to detect if it's likely a header/logo page\n   */\n  private analyzePageContent(textContent: any, pageNumber: number): {\n    isLikelyHeaderPage: boolean;\n    textDensity: number;\n    hasLowTextContent: boolean;\n  } {\n    const textItems = textContent.items || [];\n    const totalText = textItems.map((item: any) => item.str).join(' ').trim();\n    const textLength = totalText.length;\n    \n    // Page 1 with low text content often contains logos/headers\n    const isFirstPage = pageNumber === 1;\n    const hasLowTextContent = textLength < 200; // Less than 200 chars suggests header/logo page\n    const textDensity = textLength / Math.max(textItems.length, 1); // Avg chars per text item\n    \n    // Look for header-like patterns\n    const hasHeaderKeywords = /bill|statement|invoice|report|summary|account|period/i.test(totalText);\n    const hasDatePattern = /\\d{1,2}[-\\/]\\d{1,2}[-\\/]\\d{2,4}|\\w+ \\d{1,2}, \\d{4}/i.test(totalText);\n    const hasAmountPattern = /\\$[\\d,]+\\.?\\d*|USD|EUR|GBP/i.test(totalText);\n    \n    const isLikelyHeaderPage = isFirstPage && (\n      hasLowTextContent || \n      (hasHeaderKeywords && hasDatePattern && hasAmountPattern && textLength < 500)\n    );\n    \n    this.log(`Page ${pageNumber} content analysis: textLength=${textLength}, textDensity=${textDensity.toFixed(1)}, isLikelyHeader=${isLikelyHeaderPage}`);\n    \n    return {\n      isLikelyHeaderPage,\n      textDensity,\n      hasLowTextContent\n    };\n  }\n\n  /**\n   * Advanced text sharpness analysis for PDF documents\n   */\n  private async analyzeTextSharpness(pdf: any, pageNumber: number): Promise<{\n    textSharpnessScore: number;\n    isTextBlurry: boolean;\n    textMetrics: any;\n  }> {\n    const page = await pdf.getPage(pageNumber);\n    const textContent = await page.getTextContent();\n    \n    if (textContent.items.length === 0) {\n      return {\n        textSharpnessScore: 0,\n        isTextBlurry: true,\n        textMetrics: { reason: 'No text found' }\n      };\n    }\n\n    // Render at high resolution for text analysis\n    const viewport = page.getViewport({ scale: 3.0 });\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    if (!context) {\n      throw new Error('Could not get 2D context for text analysis');\n    }\n\n    canvas.width = viewport.width;\n    canvas.height = viewport.height;\n\n    // Render only text (no images) for cleaner analysis\n    const renderContext = { \n      canvasContext: context, \n      viewport,\n      intent: 'print' // Better text rendering\n    };\n    await page.render(renderContext).promise;\n\n    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    \n    // Analyze text regions for sharpness\n    const textSharpness = this.calculateTextSharpness(imageData, textContent.items);\n    \n    this.log(`Page ${pageNumber} text sharpness analysis:`, textSharpness);\n    \n    return textSharpness;\n  }\n\n  /**\n   * Calculate sharpness specifically for text regions\n   */\n  private calculateTextSharpness(imageData: ImageData, textItems: any[]): {\n    textSharpnessScore: number;\n    isTextBlurry: boolean;\n    textMetrics: any;\n  } {\n    const { data, width, height } = imageData;\n    let totalVariance = 0;\n    let sampleCount = 0;\n    let edgeIntensity = 0;\n\n    // Sample text regions more intelligently\n    const sampleSize = 5; // Size of sampling window\n    const stride = Math.max(1, Math.floor(Math.min(width, height) / 100)); // Adaptive stride\n\n    for (let y = 0; y < height - sampleSize; y += stride) {\n      for (let x = 0; x < width - sampleSize; x += stride) {\n        // Calculate local variance in this region\n        let localSum = 0;\n        let localSumSq = 0;\n        let localCount = 0;\n        let maxGradient = 0;\n\n        for (let dy = 0; dy < sampleSize; dy++) {\n          for (let dx = 0; dx < sampleSize; dx++) {\n            const idx = ((y + dy) * width + (x + dx)) * 4;\n            \n            // Convert to grayscale\n            const gray = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];\n            \n            localSum += gray;\n            localSumSq += gray * gray;\n            localCount++;\n\n            // Calculate gradient magnitude for edge detection\n            if (dx < sampleSize - 1 && dy < sampleSize - 1) {\n              const rightIdx = ((y + dy) * width + (x + dx + 1)) * 4;\n              const downIdx = ((y + dy + 1) * width + (x + dx)) * 4;\n              \n              const rightGray = 0.299 * data[rightIdx] + 0.587 * data[rightIdx + 1] + 0.114 * data[rightIdx + 2];\n              const downGray = 0.299 * data[downIdx] + 0.587 * data[downIdx + 1] + 0.114 * data[downIdx + 2];\n              \n              const gradX = rightGray - gray;\n              const gradY = downGray - gray;\n              const gradient = Math.sqrt(gradX * gradX + gradY * gradY);\n              \n              maxGradient = Math.max(maxGradient, gradient);\n            }\n          }\n        }\n\n        if (localCount > 0) {\n          const mean = localSum / localCount;\n          const variance = (localSumSq / localCount) - (mean * mean);\n          \n          // Weight regions with higher variance (likely text)\n          if (variance > 100) { // Threshold for text-like regions\n            totalVariance += variance;\n            edgeIntensity += maxGradient;\n            sampleCount++;\n          }\n        }\n      }\n    }\n\n    const avgVariance = sampleCount > 0 ? totalVariance / sampleCount : 0;\n    const avgEdgeIntensity = sampleCount > 0 ? edgeIntensity / sampleCount : 0;\n    \n    // Combined sharpness score\n    const sharpnessScore = (avgVariance / 1000) + (avgEdgeIntensity / 50);\n    \n    // Thresholds based on typical text characteristics\n    const isTextBlurry = sharpnessScore < 0.8; // Adjust based on testing\n    \n    return {\n      textSharpnessScore: sharpnessScore,\n      isTextBlurry,\n      textMetrics: {\n        avgVariance,\n        avgEdgeIntensity,\n        sampleCount,\n        threshold: 0.8\n      }\n    };\n  }\n\n  /**\n   * Analyze a PDF file for quality and blur\n   */\n  async analyzePDF(file: File): Promise<PDFAnalysisResult> {\n    this.log('Starting PDF analysis for file:', file.name);\n\n    if (!this.pdfLib) {\n      await this.loadPdfJS();\n    }\n\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      const pdf = await this.pdfLib.getDocument({ data: new Uint8Array(arrayBuffer) }).promise;\n\n      let extractedText = '';\n      let isScanned = false;\n      const pageResults: BlurAnalysisResult[] = [];\n\n      this.log(`PDF has ${pdf.numPages} pages`);\n\n      // Check all pages for text content and quality\n      for (let i = 1; i <= pdf.numPages; i++) {\n        this.log(`Analyzing page ${i}/${pdf.numPages}`);\n        \n        const page = await pdf.getPage(i);\n        const textContent = await page.getTextContent();\n\n        // Check if page has text content\n        if (textContent.items.length === 0) {\n          isScanned = true;\n        }\n\n        extractedText += textContent.items.map((item: any) => item.str).join(' ');\n\n        // Analyze page for blur using multiple methods\n        try {\n          // First, analyze page content to understand its nature\n          const contentAnalysis = this.analyzePageContent(textContent, i);\n          \n          const pageAnalysis = await this.checkPdfPageQuality(pdf, i);\n          \n          // For text-based PDFs, also do text sharpness analysis\n          if (textContent.items.length > 0) {\n            try {\n              const textSharpness = await this.analyzeTextSharpness(pdf, i);\n              \n              // Smart blur decision based on content type\n              let finalIsBlurry = pageAnalysis.isBlurry || textSharpness.isTextBlurry;\n              \n              // If this looks like a header/logo page, be more lenient\n              if (contentAnalysis.isLikelyHeaderPage) {\n                // Only consider blurry if text sharpness is very poor\n                finalIsBlurry = textSharpness.textSharpnessScore < 0.5; // More lenient threshold\n                this.log(`Page ${i} identified as likely header/logo page - using lenient blur criteria`);\n              }\n              \n              const combinedResult: BlurAnalysisResult = {\n                ...pageAnalysis,\n                isBlurry: finalIsBlurry,\n                confidence: Math.max(pageAnalysis.confidence, textSharpness.textSharpnessScore),\n                method: `${pageAnalysis.method} + Text Analysis${contentAnalysis.isLikelyHeaderPage ? ' (Header-adjusted)' : ''}`,\n                metrics: {\n                  ...pageAnalysis.metrics,\n                  textSharpness: textSharpness,\n                  contentAnalysis: contentAnalysis\n                }\n              };\n              \n              pageResults.push(combinedResult);\n              this.log(`Page ${i} combined analysis:`, combinedResult);\n            } catch (textError) {\n              this.log(`Text analysis failed for page ${i}:`, textError);\n              pageResults.push(pageAnalysis);\n            }\n          } else {\n            pageResults.push(pageAnalysis);\n          }\n          \n        } catch (error) {\n          this.log(`Failed to analyze page ${i}:`, error);\n          // Continue with other pages\n        }\n      }\n\n      // Determine if PDF is scanned based on text content\n      const isTextBased = extractedText.length >= 10;\n      const finalIsScanned = isScanned || !isTextBased;\n\n      this.log(`PDF analysis complete. Scanned: ${finalIsScanned}, Text length: ${extractedText.length}`);\n\n      // Determine overall quality with smart logic for first page issues\n      let isQualityGood = true;\n      \n      if (pageResults.length > 0) {\n        const blurryPages = pageResults.filter(result => result.isBlurry);\n        \n        // Smart quality assessment for multi-page documents\n        if (pageResults.length > 1) {\n          // For multi-page docs, use majority rule but be lenient with first page\n          const nonFirstPageResults = pageResults.slice(1);\n          const blurryNonFirstPages = nonFirstPageResults.filter(result => result.isBlurry);\n          \n          // If first page is blurry but rest are clear, likely false positive\n          const firstPageBlurry = pageResults[0].isBlurry;\n          const restPagesBlurry = blurryNonFirstPages.length > 0;\n          \n          if (firstPageBlurry && !restPagesBlurry) {\n            // First page alone is blurry - likely contains graphics/logos\n            this.log('First page marked as blurry but rest are clear - likely false positive due to graphics/logos');\n            isQualityGood = true;\n          } else if (blurryNonFirstPages.length >= Math.ceil(nonFirstPageResults.length / 2)) {\n            // Majority of non-first pages are blurry\n            isQualityGood = false;\n          } else {\n            // Most pages are clear\n            isQualityGood = true;\n          }\n          \n          this.log(`Smart quality check: First page blurry: ${firstPageBlurry}, Rest pages blurry: ${blurryNonFirstPages.length}/${nonFirstPageResults.length}, Final decision: ${isQualityGood ? 'Good' : 'Poor'}`);\n        } else {\n          // Single page - use original logic\n          isQualityGood = blurryPages.length === 0;\n          this.log(`Single page quality check: ${blurryPages.length}/${pageResults.length} pages are blurry`);\n        }\n        \n        this.log(`PDF type: ${finalIsScanned ? 'Scanned' : 'Text-based'}`);\n      }\n\n      const result: PDFAnalysisResult = {\n        isQualityGood,\n        isScanned: finalIsScanned,\n        pagesAnalyzed: pdf.numPages,\n        textLength: extractedText.length,\n        pageResults: pageResults.length > 0 ? pageResults : undefined\n      };\n\n      this.log('Final PDF analysis result:', result);\n      return result;\n\n    } catch (error) {\n      this.log('PDF analysis failed:', error);\n      throw new Error(`PDF analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Quick check if a PDF is of good quality\n   */\n  async isGoodQuality(file: File): Promise<boolean> {\n    const result = await this.analyzePDF(file);\n    return result.isQualityGood;\n  }\n}","/**\n * Blurry Check - A comprehensive blur detection library for images and PDFs\n * \n * @example\n * ```typescript\n * import { BlurryCheck } from 'blurry-check';\n * \n * const checker = new BlurryCheck({\n *   method: 'both',\n *   edgeWidthThreshold: 0.5,\n *   debug: true\n * });\n * \n * // Check an image file\n * const isBlurry = await checker.isImageBlurry(imageFile);\n * \n * // Get detailed analysis\n * const analysis = await checker.analyzeImage(imageFile);\n * \n * // Check PDF quality\n * const pdfResult = await checker.analyzePDF(pdfFile);\n * ```\n */\n\nexport { BlurDetector } from './blur-detector';\nexport { PDFAnalyzer } from './pdf-analyzer';\nexport { OpenCVLoader } from './opencv-loader';\nexport { Filters } from './filters';\nexport * from './types';\n\nimport { BlurDetector } from './blur-detector';\nimport { PDFAnalyzer } from './pdf-analyzer';\nimport { \n  BlurDetectionConfig, \n  BlurAnalysisResult, \n  PDFAnalysisResult,\n  FileAnalysisOptions \n} from './types';\n\n/**\n * Main BlurryCheck class - simplified interface for blur detection\n */\nexport class BlurryCheck {\n  private blurDetector: BlurDetector;\n  private pdfAnalyzer: PDFAnalyzer;\n  private config: BlurDetectionConfig;\n\n  constructor(config: BlurDetectionConfig = {}) {\n    this.config = {\n      edgeWidthThreshold: 0.5,\n      laplacianThreshold: 100,\n      method: 'edge',\n      debug: false,\n      ...config\n    };\n\n    this.blurDetector = new BlurDetector(this.config);\n    this.pdfAnalyzer = new PDFAnalyzer(this.config);\n  }\n\n  /**\n   * Check if an image is blurry (simple boolean result)\n   */\n  async isImageBlurry(\n    input: HTMLImageElement | HTMLCanvasElement | File | ImageData\n  ): Promise<boolean> {\n    return this.blurDetector.isBlurry(input);\n  }\n\n  /**\n   * Analyze an image for blur with detailed metrics\n   */\n  async analyzeImage(\n    input: HTMLImageElement | HTMLCanvasElement | File | ImageData\n  ): Promise<BlurAnalysisResult> {\n    return this.blurDetector.analyzeImage(input);\n  }\n\n  /**\n   * Check if a PDF is of good quality (simple boolean result)\n   */\n  async isPDFGoodQuality(file: File): Promise<boolean> {\n    return this.pdfAnalyzer.isGoodQuality(file);\n  }\n\n  /**\n   * Analyze a PDF for quality and blur with detailed metrics\n   */\n  async analyzePDF(file: File): Promise<PDFAnalysisResult> {\n    return this.pdfAnalyzer.analyzePDF(file);\n  }\n\n  /**\n   * Analyze any supported file type automatically\n   */\n  async analyzeFile(\n    file: File,\n    options: FileAnalysisOptions = {}\n  ): Promise<BlurAnalysisResult | PDFAnalysisResult> {\n    const fileExtension = file.name.split('.').pop()?.toLowerCase();\n    \n    // Merge options with instance config\n    const mergedConfig = { ...this.config, ...options };\n\n    if (fileExtension === 'pdf') {\n      const pdfAnalyzer = new PDFAnalyzer(mergedConfig);\n      return pdfAnalyzer.analyzePDF(file);\n    }\n\n    if (['png', 'jpg', 'jpeg', 'gif', 'bmp', 'webp'].includes(fileExtension || '')) {\n      const blurDetector = new BlurDetector(mergedConfig);\n      return blurDetector.analyzeImage(file);\n    }\n\n    throw new Error(`Unsupported file type: ${fileExtension}`);\n  }\n\n  /**\n   * Quick check for any supported file type\n   */\n  async isFileGoodQuality(\n    file: File,\n    options: FileAnalysisOptions = {}\n  ): Promise<boolean> {\n    const result = await this.analyzeFile(file, options);\n    \n    if ('isQualityGood' in result) {\n      return result.isQualityGood; // PDF result\n    } else {\n      return !result.isBlurry; // Image result\n    }\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<BlurDetectionConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    this.blurDetector = new BlurDetector(this.config);\n    this.pdfAnalyzer = new PDFAnalyzer(this.config);\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): BlurDetectionConfig {\n    return { ...this.config };\n  }\n}\n\n/**\n * Convenience functions for quick usage\n */\n\n/**\n * Quick check if an image is blurry with default settings\n */\nexport async function isImageBlurry(\n  input: HTMLImageElement | HTMLCanvasElement | File | ImageData,\n  config?: BlurDetectionConfig\n): Promise<boolean> {\n  const checker = new BlurryCheck(config);\n  return checker.isImageBlurry(input);\n}\n\n/**\n * Quick check if a PDF is of good quality with default settings\n */\nexport async function isPDFGoodQuality(\n  file: File,\n  config?: BlurDetectionConfig\n): Promise<boolean> {\n  const checker = new BlurryCheck(config);\n  return checker.isPDFGoodQuality(file);\n}\n\n/**\n * Quick analysis of any supported file type with default settings\n */\nexport async function analyzeFile(\n  file: File,\n  options?: FileAnalysisOptions\n): Promise<BlurAnalysisResult | PDFAnalysisResult> {\n  const checker = new BlurryCheck(options);\n  return checker.analyzeFile(file, options);\n}\n\n// Default export\nexport default BlurryCheck;"],"names":["Filters","getFloat32Array","len","Array","isArray","slice","Float32Array","createImageData","w","h","context","document","createElement","Error","createCanvas","getContext","luminance","pixels","output","this","width","height","dst","data","d","i","length","v","convolve","weights","opaque","side","Math","round","sqrt","halfSide","floor","src","sw","sh","alphaFac","y","x","dstOff","r","g","b","a","cy","cx","srcOff","min","max","wt","gaussianBlur","diameter","abs","radius","ceil","rho","rhoSq","gaussianFactor","PI","rhoFactor","middle","wsum","gx","exp","firstPass","OpenCVLoader","constructor","openCvUrl","loading","loaded","getInstance","instance","loadOpenCV","window","cv","Promise","resolve","waitForLoad","existingScript","querySelector","body","removeChild","script","async","id","loadPromise","reject","onload","checkInterval","setInterval","clearInterval","setTimeout","onerror","appendChild","error","isLoaded","getCV","BlurDetector","config","edgeWidthThreshold","_a","laplacianThreshold","_b","method","_c","_d","canvas","_e","debug","_f","openCvLoader","log","message","args","console","detectEdges","imageData","greyscaled","sobelKernel","reducedPixels","rowLen","rows","row","Uint8ClampedArray","push","detectBlur","numEdges","sumEdgeWidths","edgeStart","value","oldValue","avgEdgeWidth","avgEdgeWidthPerc","measureBlurByEdges","edges","reducedPixelData","detectBlurrinessWithOpenCV","mat","matFromImageData","gray","Mat","cvtColor","COLOR_RGBA2GRAY","laplacian","Laplacian","CV_64F","meanStdDev","stddev","variance","data64F","delete","getImageData","input","ImageData","ctx","File","reader","FileReader","e","img","Image","drawImage","target","result","readAsDataURL","HTMLImageElement","HTMLCanvasElement","srcCtx","analyzeImage","isBlurry","confidence","metrics","edgeAnalysis","isBlurryByEdge","hasLowEdgeCount","combinedBlurCheck","laplacianVariance","isBlurryByLaplacian","edgeBlurry","combinedEdgeBlurry","laplacianBlurry","edgeConfidence","laplacianConfidence","PDFAnalyzer","pdfLib","blurDetector","loadPdfJS","pdfjsLib","GlobalWorkerOptions","workerSrc","checkPdfPageQuality","pdf","pageNumber","page","getPage","scales","results","scale","viewport","getViewport","renderContext","canvasContext","render","promise","pdfBlurDetector","then","blurryCount","filter","avgConfidence","reduce","sum","bestResult","scaleResults","map","parseFloat","match","analyzePageContent","textContent","textItems","items","totalText","item","str","join","trim","textLength","isFirstPage","hasLowTextContent","textDensity","hasHeaderKeywords","test","hasDatePattern","hasAmountPattern","isLikelyHeaderPage","toFixed","analyzeTextSharpness","getTextContent","textSharpnessScore","isTextBlurry","textMetrics","reason","intent","textSharpness","calculateTextSharpness","totalVariance","sampleCount","edgeIntensity","stride","localSum","localSumSq","localCount","maxGradient","dy","dx","idx","sampleSize","rightIdx","downIdx","gradX","gradY","gradient","mean","avgVariance","avgEdgeIntensity","sharpnessScore","threshold","analyzePDF","file","name","arrayBuffer","getDocument","Uint8Array","extractedText","isScanned","pageResults","numPages","contentAnalysis","pageAnalysis","finalIsBlurry","combinedResult","textError","isTextBased","finalIsScanned","isQualityGood","blurryPages","nonFirstPageResults","blurryNonFirstPages","firstPageBlurry","restPagesBlurry","pagesAnalyzed","undefined","isGoodQuality","BlurryCheck","pdfAnalyzer","isImageBlurry","isPDFGoodQuality","analyzeFile","options","fileExtension","split","pop","toLowerCase","mergedConfig","includes","isFileGoodQuality","updateConfig","newConfig","getConfig"],"mappings":"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"}